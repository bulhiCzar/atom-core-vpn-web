var f=Object.defineProperty;var A=(i,c,r)=>c in i?f(i,c,{enumerable:!0,configurable:!0,writable:!0,value:r}):i[c]=r;var p=(i,c,r)=>(A(i,typeof c!="symbol"?c+"":c,r),r);import{gn as W,fe as C,ff as T,go as v,fh as y,g5 as I,o as E,fj as l,fv as k,fk as h,fw as R}from"./index-bf7e6b01.js";import{h as $}from"./hasERC20Allowance-a42cbfcb.browser.esm-1049ca41.js";import{a as g}from"./marketplace-2c4d64bd.browser.esm-5dd41dfa.js";import{b}from"./QueryParams-5e052686.browser.esm-6f6b2f03.js";import{C as S,a as P,G as q,b as F}from"./contract-appuri-b5a92ae1.browser.esm-3f09c586.js";import{C as L,a as O}from"./contract-owner-62e3d0ab.browser.esm-930e40df.js";import{C as U}from"./contract-roles-9a1af853.browser.esm-cb3e4968.js";import{S as x}from"./erc-721-standard-e22ed133.browser.esm-605205c8.js";import"./setErc20Allowance-ef5f1102.browser.esm-58da34aa.js";import"./signature-67894a84.browser.esm-fb9ac756.js";import"./treeify-3e444e74.js";import"./assertEnabled-61eec3a0.browser.esm-a7112682.js";import"./erc-721-67cd0472.browser.esm-8ec3c027.js";import"./drop-claim-conditions-d8589bc7.browser.esm-2229fc44.js";import"./index-e18a6d9c.js";const d=class d extends x{constructor(r,e,n){let o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},t=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&arguments[6]!==void 0?arguments[6]:new C(r,e,t,o,n);super(s,n,a);p(this,"wrap",l(async(r,e,n)=>{const[o,t,a]=await Promise.all([b(e,this.storage),this.toTokenStructList(r),k(n||await this.contractWrapper.getSignerAddress())]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"wrap",args:[t,o,a],parse:s=>{const u=this.contractWrapper.parseLogs("TokensWrapped",s==null?void 0:s.logs);if(u.length===0)throw new Error("TokensWrapped event not found");const m=u[0].args.tokenIdOfWrappedToken;return{id:m,receipt:s,data:()=>this.get(m)}}})}));p(this,"unwrap",l(async(r,e)=>{const n=await k(e||await this.contractWrapper.getSignerAddress());return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"unwrap",args:[r,n]})}));this.abi=T.parse(t||[]),this.metadata=new S(this.contractWrapper,v,this.storage),this.app=new P(this.contractWrapper,this.metadata,this.storage),this.roles=new U(this.contractWrapper,d.contractRoles),this.encoder=new y(this.contractWrapper),this.estimator=new q(this.contractWrapper),this.events=new F(this.contractWrapper),this.royalties=new L(this.contractWrapper,this.metadata),this.owner=new O(this.contractWrapper)}async getWrappedContents(r){const e=await this.contractWrapper.read("getWrappedContents",[r]),n=[],o=[],t=[];for(const a of e)switch(a.tokenType){case 0:{const s=await I(this.contractWrapper.getProvider(),a.assetContract);n.push({contractAddress:a.assetContract,quantity:E(a.totalAmount,s.decimals)});break}case 1:{o.push({contractAddress:a.assetContract,tokenId:a.tokenId});break}case 2:{t.push({contractAddress:a.assetContract,tokenId:a.tokenId,quantity:a.totalAmount.toString()});break}}return{erc20Tokens:n,erc721Tokens:o,erc1155Tokens:t}}async toTokenStructList(r){const e=[],n=this.contractWrapper.getProvider(),o=await this.contractWrapper.getSignerAddress();if(r.erc20Tokens)for(const t of r.erc20Tokens){const a=await R(n,t.quantity,t.contractAddress);if(!await $(this.contractWrapper,t.contractAddress,a))throw new Error(`ERC20 token with contract address "${t.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${t.contractAddress}").setAllowance("${this.getAddress()}", ${t.quantity});

`);e.push({assetContract:t.contractAddress,totalAmount:a,tokenId:0,tokenType:0})}if(r.erc721Tokens)for(const t of r.erc721Tokens){if(!await g(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,o))throw new Error(`ERC721 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${t.contractAddress}").setApprovalForToken("${this.getAddress()}", ${t.tokenId});

`);e.push({assetContract:t.contractAddress,totalAmount:0,tokenId:t.tokenId,tokenType:1})}if(r.erc1155Tokens)for(const t of r.erc1155Tokens){if(!await g(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,o))throw new Error(`ERC1155 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${t.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);e.push({assetContract:t.contractAddress,totalAmount:t.quantity,tokenId:t.tokenId,tokenType:2})}return e}async prepare(r,e,n){return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:r,args:e,overrides:n})}async call(r,e,n){return this.contractWrapper.call(r,e,n)}};p(d,"contractRoles",W);let w=d;export{w as Multiwrap};
